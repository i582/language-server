## Language Support in IDEs

Этот документ описывает необходимую функциональность для поддержки языка в таких редакторах как JetBrains IDEs, VS Code и другие.

## Base implementation

VS Code и другие редакторы используют протокол LSP который определяет общение между Language Server и редактором.

JB IDEs используют собственный API для поддержки языка в рамках IDE, пусть они добавили первичную поддержку LSP, этот API все еще очень сильно уступает встроенному в IDE.

## Features

### Completion

Автодополнение представляет собой возможность движка давать список возможных вариантов для использования в месте курсора. Дополнение можно разделить на две части, структурные и логические.

#### Structure completion

Структурное автодополнение включает в себя автодополнение ключевых слов, конструкций типа if/else или создание пустых структур, контрактов и прочего. Такое автодополнение не требует дополнительной информации из других файлов. Такое автодополнение может быть реализована в обоих API.

Поддержка в IDE: JetBrains ✅, VS Code ✅

Следующий список показывает все необходимые конструкции, для которых мы хотим видеть такое автодополнение:

- `contract Name {}`
- `struct Name {}`
- `message Name {}`
- `trait Name {}`
- `const Name: Type = value`
- `if (cond) {}`
- `else {}/else-if (cond) {}`
- `while (cond) {}`
- `do {} unril (cond);`
- `foreach (key, value in map) {}`

##### Postfix completion

Поддержка в IDE: JetBrains ✅, VS Code ❓

Постфиксное автодополнение это частный случай структурного автодополнения. Это автодополнение срабатывает когда пользователь написал некоторый постфикс (например, for) и нажал автодополнение, в этом случае такое автодополнение разворачивает слово в целую конструкцию (в примере, в foreach).

```
mapping.for<caret>
```

Конвертируется в:

```
foreach (key, value in mapping) {}
```

Следующий список показывает все необходимые конструкции, для которых мы хотим видеть такое автодополнение:

- `<expr>.for` для `foreach (key, value in expr)`
- `<expr>.let` для `let name = expr`
- `<expr>.dump` для `dump(expr)`

#### Logical completion

Поддержка в IDE: JetBrains ✅, VS Code ✅

Логическое автодополнение работает как автодополнение, которое учитывает логику языка (например, определения переменных или функций) и использует вывод типов для своей работы (автодополнение полей или методов после точки).

```
fun bar(): Int { return 0; }

fun foo(param: Cell) {
	let a = bar();
	if (a == 10) {
		<caret>
	}
}
```

Например, в примере выше, логическое автодополнение должно предложить переменную `a`, параметр `param` и функции `bar` и `foo`.

Следующий список показывает ключевые слова которые должны автодополняться с учетом логики:

- `return` - Автодополнение `return` должно учитывать возвращаемый тип функции. Если функция не возвращает ничего, при автодополнении должна вставляться автоматическая точка с запятой. Если функция возвращает числа, строки или boolean, то в списке автодополнения должны быть варианты с проставленным дефолтным значением. Если функция возвращает что-либо, при автодополнении каретка должны быть после return через пробел, за которой должна идти точка с запятой `return <cursor>;` 

Следующий список показывает какие определения должны быть в автодополнении в рамках функции:

- Локальные переменные определенные до места функции, где расположена каретка
- Параметры функции в которой находится каретка
- Top-level определения из файла и импортированных модулей (включая stdlib)
  - При автодополнении функции: 
    - если функция не принимает аргументов, курсор должен ставиться после скобок `foo()<caret>`
    - если функция принимает один аргумент `self` и вызывается как метод, курсор должен ставиться после скобок `a.foo()<caret>`
    - в остальных случаях, когда у функции есть аргументы, каретка должна помещаться внутри скобок: `foo(<caret>)`
  - При автодополнении структур:
    - необходимо вставить имя и фигурные скобки, поместив курсор между ними: `Foo {<caret>}`
    - после автодополнения автоматически вызывать автодополнение (JetBrains ✅, VS Code ❓) для автодополнения полей
    - если каретка находится на месте, где ожидается тип, не вставлять фигурные скобки
- Методы трейта или контракта в которых находится каретка
  - при автодополнении необходимо автоматически вставить `self.` префикс, чтобы код корректно вызывал этот метод
  - вставка скобок и перемещение каретки используют те же правила что и для функций
- Если каретка находится внутри `Foo { <caret> }` и `Foo` это структура или сообщение, то предлагать быстрое действие (JetBrains ✅, VS Code ❓) которое автоматически заполнит все поля дефолтными значениями с их редактированием через tab.
- Если каретка находится внутри `Foo { <caret> }` и `Foo` это структура или сообщение, предлагать автодополнение для полей этой структуры/сообщения. Если поле уже было ранее заполнено, оно не должно появляться в списке. Учитывать, что поля могут быть заполнены без указания ключа (`Foo { 10, 20, <caret> }`).


Следующий список показывает какие определения должны быть в автодополнении типа:

- Top-level определения из файла и импортированных модулей (включая stdlib) включая структуры, сообщения, трейты и примитивы

**Dot completion**

Dot автодополнение вызывается, когда пользователь вводит точку (`foo.<caret>`). Такое автодополнение используется для полей и методов.
