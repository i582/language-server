=========
@trigger .
Message fields completion
=========
message Transfer {
    amount: Int;
    to: Address;
}

fun test(msg: Transfer) {
    msg.<caret>
}
------------
amount
to

=========
@trigger .
Struct fields completion
=========
struct Point {
    x: Int;
    y: Int as uint32;
    z: Int?;
}

fun test(p: Point) {
    p.<caret>
}
------------
x
y
z

=========
@trigger .
Contract fields completion
=========
contract Counter {
    val: Int;
    owner: Address;

    init(owner: Address) {
        self.owner = owner;
        self.val = 0;
    }
}

fun test(c: Counter) {
    c.<caret>
}
------------
owner
val

=========
@trigger .
Map fields completion
=========
struct Storage {
    balances: map<Address, Int>;
    allowances: map<Address, map<Address, Int>>;
}

fun test(s: Storage) {
    s.<caret>
}
------------
allowances
balances

=========
@trigger .
Optional fields completion
=========
struct User {
    name: String;
    age: Int?;
    address: Address?;
}

fun test(u: User?) {
    u.<caret>
}
------------
address
age
name

=========
@trigger .
Nested fields completion
=========
struct Inner {
    value: Int;
}

struct Outer {
    inner: Inner;
}

fun test(o: Outer) {
    o.inner.<caret>
}
------------
value

=========
@trigger .
Message with TLB fields completion
=========
message TokenTransfer {
    queryId: Int as uint64;
    amount: Int as coins;
    from: Address;
    to: Address;
    responseDestination: Address?;
}

fun test(msg: TokenTransfer) {
    msg.<caret>
}
------------
amount
from
queryId
responseDestination
to

=========
@trigger .
Field of bounced<struct>
=========
struct User {
    name: String;
    age: Int?;
    address: Address?;
}

contract Foo {
    receive(b: bounced<User>) {
        b.<caret>
    }
}
------------
address
age
name

=========
@trigger .
Field of option struct without unwrapping
=========
struct User {
    name: String;
    age: Int?;
    address: Address?;
}

fun foo(f: User?) {
    f.<caret>
}
------------
address
age
name

=========
@trigger .
Field of option struct with unwrapping
=========
struct User {
    name: String;
    age: Int?;
    address: Address?;
}

fun foo(f: User?) {
    f!!.<caret>
}
------------
address
age
name
